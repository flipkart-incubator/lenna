// auto generated by go tool dist
// goos=linux goarch=amd64


#include "runtime.h"
#include "defs_GOOS_GOARCH.h"
#include "os_GOOS.h"
#include "arch_GOARCH.h"
#include "malloc.h"
#include "funcdata.h"

#line 16 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
typedef struct Ftab Ftab; 
struct Ftab 
{ 
uintptr entry; 
uintptr funcoff; 
} ; 
#line 23 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
extern byte pclntab[]; 
#line 25 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
static Ftab *ftab; 
static uintptr nftab; 
static uint32 *filetab; 
static uint32 nfiletab; 
#line 30 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
static String end = { ( uint8* ) "end" , 3 } ; 
#line 32 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
void 
runtime·symtabinit ( void ) 
{ 
int32 i , j; 
Func *f1 , *f2; 
#line 41 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
if ( * ( uint32* ) pclntab != 0xfffffffb || pclntab[4] != 0 || pclntab[5] != 0 || pclntab[6] != PCQuantum || pclntab[7] != sizeof ( void* ) ) { 
runtime·printf ( "runtime: function symbol table header: %x %x\n" , * ( uint32* ) pclntab , * ( uint32* ) ( pclntab+4 ) ) ; 
runtime·throw ( "invalid function symbol table\n" ) ; 
} 
#line 46 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
nftab = * ( uintptr* ) ( pclntab+8 ) ; 
ftab = ( Ftab* ) ( pclntab+8+sizeof ( void* ) ) ; 
for ( i=0; i<nftab; i++ ) { 
#line 50 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
if ( ftab[i].entry > ftab[i+1].entry ) { 
f1 = ( Func* ) ( pclntab + ftab[i].funcoff ) ; 
f2 = ( Func* ) ( pclntab + ftab[i+1].funcoff ) ; 
runtime·printf ( "function symbol table not sorted by program counter: %p %s > %p %s" , ftab[i].entry , runtime·funcname ( f1 ) , ftab[i+1].entry , i+1 == nftab ? "end" : runtime·funcname ( f2 ) ) ; 
for ( j=0; j<=i; j++ ) 
runtime·printf ( "\t%p %s\n" , ftab[j].entry , runtime·funcname ( ( Func* ) ( pclntab + ftab[j].funcoff ) ) ) ; 
runtime·throw ( "invalid runtime symbol table" ) ; 
} 
} 
#line 60 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
filetab = ( uint32* ) ( pclntab + * ( uint32* ) &ftab[nftab].funcoff ) ; 
nfiletab = filetab[0]; 
} 
#line 64 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
static uint32 
readvarint ( byte **pp ) 
{ 
byte *p; 
uint32 v; 
int32 shift; 
#line 71 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
v = 0; 
p = *pp; 
for ( shift = 0;; shift += 7 ) { 
v |= ( *p & 0x7F ) << shift; 
if ( ! ( *p++ & 0x80 ) ) 
break; 
} 
*pp = p; 
return v; 
} 
#line 82 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
void* 
runtime·funcdata ( Func *f , int32 i ) 
{ 
byte *p; 
#line 87 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
if ( i < 0 || i >= f->nfuncdata ) 
return nil; 
p = ( byte* ) &f->nfuncdata + 4 + f->npcdata*4; 
if ( sizeof ( void* ) == 8 && ( ( uintptr ) p & 4 ) ) { 
if ( ( ( uintptr ) f & 4 ) ) 
runtime·printf ( "misaligned func %p\n" , f ) ; 
p += 4; 
} 
return ( ( void** ) p ) [i]; 
} 
#line 98 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
static bool 
step ( byte **pp , uintptr *pc , int32 *value , bool first ) 
{ 
uint32 uvdelta , pcdelta; 
int32 vdelta; 
#line 104 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
uvdelta = readvarint ( pp ) ; 
if ( uvdelta == 0 && !first ) 
return 0; 
if ( uvdelta&1 ) 
uvdelta = ~ ( uvdelta>>1 ) ; 
else 
uvdelta >>= 1; 
vdelta = ( int32 ) uvdelta; 
pcdelta = readvarint ( pp ) * PCQuantum; 
*value += vdelta; 
*pc += pcdelta; 
return 1; 
} 
#line 120 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
static int32 
pcvalue ( Func *f , int32 off , uintptr targetpc , bool strict ) 
{ 
byte *p; 
uintptr pc; 
int32 value; 
#line 127 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
enum { 
debug = 0 
} ; 
#line 137 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
if ( off == 0 ) 
return -1; 
p = pclntab + off; 
pc = f->entry; 
value = -1; 
#line 143 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
if ( debug && !runtime·panicking ) 
runtime·printf ( "pcvalue start f=%s [%p] pc=%p targetpc=%p value=%d tab=%p\n" , 
runtime·funcname ( f ) , f , pc , targetpc , value , p ) ; 
#line 147 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
while ( step ( &p , &pc , &value , pc == f->entry ) ) { 
if ( debug ) 
runtime·printf ( "\tvalue=%d until pc=%p\n" , value , pc ) ; 
if ( targetpc < pc ) 
return value; 
} 
#line 156 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
if ( runtime·panicking || !strict ) 
return -1; 
runtime·printf ( "runtime: invalid pc-encoded table f=%s pc=%p targetpc=%p tab=%p\n" , 
runtime·funcname ( f ) , pc , targetpc , p ) ; 
p = ( byte* ) f + off; 
pc = f->entry; 
value = -1; 
#line 164 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
while ( step ( &p , &pc , &value , pc == f->entry ) ) 
runtime·printf ( "\tvalue=%d until pc=%p\n" , value , pc ) ; 
#line 167 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
runtime·throw ( "invalid runtime symbol table" ) ; 
return -1; 
} 
#line 171 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
static String unknown = { ( uint8* ) "?" , 1 } ; 
#line 173 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
int8* 
runtime·funcname ( Func *f ) 
{ 
if ( f == nil || f->nameoff == 0 ) 
return nil; 
return ( int8* ) ( pclntab + f->nameoff ) ; 
} 
#line 181 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
static int32 
funcline ( Func *f , uintptr targetpc , String *file , bool strict ) 
{ 
int32 line; 
int32 fileno; 
#line 187 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
*file = unknown; 
fileno = pcvalue ( f , f->pcfile , targetpc , strict ) ; 
line = pcvalue ( f , f->pcln , targetpc , strict ) ; 
if ( fileno == -1 || line == -1 || fileno >= nfiletab ) { 
#line 192 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
return 0; 
} 
*file = runtime·gostringnocopy ( pclntab + filetab[fileno] ) ; 
return line; 
} 
#line 198 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
int32 
runtime·funcline ( Func *f , uintptr targetpc , String *file ) 
{ 
return funcline ( f , targetpc , file , true ) ; 
} 
#line 204 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
int32 
runtime·funcspdelta ( Func *f , uintptr targetpc ) 
{ 
int32 x; 
#line 209 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
x = pcvalue ( f , f->pcsp , targetpc , true ) ; 
if ( x& ( sizeof ( void* ) -1 ) ) 
runtime·printf ( "invalid spdelta %d %d\n" , f->pcsp , x ) ; 
return x; 
} 
#line 215 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
int32 
runtime·pcdatavalue ( Func *f , int32 table , uintptr targetpc ) 
{ 
if ( table < 0 || table >= f->npcdata ) 
return -1; 
return pcvalue ( f , ( &f->nfuncdata ) [1+table] , targetpc , true ) ; 
} 
#line 223 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
int32 
runtime·funcarglen ( Func *f , uintptr targetpc ) 
{ 
if ( targetpc == f->entry ) 
return 0; 
return runtime·pcdatavalue ( f , PCDATA_ArgSize , targetpc-PCQuantum ) ; 
} 
void
runtime·funcline_go(Func* f, uintptr targetpc, String retfile, intgo retline)
{
	retfile.str = 0;
	retfile.len = 0;
	FLUSH(&retfile);
	retline = 0;
	FLUSH(&retline);
#line 231 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"

	// Pass strict=false here, because anyone can call this function,
	// and they might just be wrong about targetpc belonging to f.
	retline = funcline(f, targetpc, &retfile, false);
	FLUSH(&retfile);
	FLUSH(&retline);
}
void
runtime·funcname_go(Func* f, String ret)
{
	ret.str = 0;
	ret.len = 0;
	FLUSH(&ret);
#line 237 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"

	ret = runtime·gostringnocopy((uint8*)runtime·funcname(f));
	FLUSH(&ret);
}
void
runtime·funcentry_go(Func* f, uintptr ret)
{
	ret = 0;
	FLUSH(&ret);
#line 241 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"

	ret = f->entry;
	FLUSH(&ret);
}

#line 245 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
Func* 
runtime·findfunc ( uintptr addr ) 
{ 
Ftab *f; 
int32 nf , n; 
#line 251 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
if ( nftab == 0 ) 
return nil; 
if ( addr < ftab[0].entry || addr >= ftab[nftab].entry ) 
return nil; 
#line 257 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
f = ftab; 
nf = nftab; 
while ( nf > 0 ) { 
n = nf/2; 
if ( f[n].entry <= addr && addr < f[n+1].entry ) 
return ( Func* ) ( pclntab + f[n].funcoff ) ; 
else if ( addr < f[n].entry ) 
nf = n; 
else { 
f += n+1; 
nf -= n+1; 
} 
} 
#line 275 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
runtime·prints ( "findfunc unreachable\n" ) ; 
return nil; 
} 
void
runtime·FuncForPC(uintptr pc, Func* ret)
{
	ret = 0;
	FLUSH(&ret);
#line 279 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"

	ret = runtime·findfunc(pc);
	FLUSH(&ret);
}

#line 283 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
static bool 
hasprefix ( String s , int8 *p ) 
{ 
int32 i; 
#line 288 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
for ( i=0; i<s.len; i++ ) { 
if ( p[i] == 0 ) 
return 1; 
if ( p[i] != s.str[i] ) 
return 0; 
} 
return p[i] == 0; 
} 
#line 297 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
static bool 
contains ( String s , int8 *p ) 
{ 
int32 i; 
#line 302 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
if ( p[0] == 0 ) 
return 1; 
for ( i=0; i<s.len; i++ ) { 
if ( s.str[i] != p[0] ) 
continue; 
if ( hasprefix ( ( String ) { s.str + i , s.len - i } , p ) ) 
return 1; 
} 
return 0; 
} 
#line 313 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
bool 
runtime·showframe ( Func *f , G *gp ) 
{ 
static int32 traceback = -1; 
String name; 
#line 319 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
if ( m->throwing > 0 && gp != nil && ( gp == m->curg || gp == m->caughtsig ) ) 
return 1; 
if ( traceback < 0 ) 
traceback = runtime·gotraceback ( nil ) ; 
name = runtime·gostringnocopy ( ( uint8* ) runtime·funcname ( f ) ) ; 
#line 328 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
if ( name.len == 7+1+5 && hasprefix ( name , "runtime.panic" ) ) 
return 1; 
#line 331 "/tmp/makerelease197226928/go/src/pkg/runtime/symtab.goc"
return traceback > 1 || f != nil && contains ( name , "." ) && !hasprefix ( name , "runtime." ) ; 
} 